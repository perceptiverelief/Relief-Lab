<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Relief Lab</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<style>
body { margin:0; overflow:hidden; background:#111; }
#ui {
  position:absolute; top:10px; left:10px;
  width:260px; background:rgba(0,0,0,0.9);
  padding:12px; border-radius:10px;
  color:white; font-family:Arial; font-size:13px;
}
.control { margin-bottom:8px; }
.control input { width:100%; }
.toggles label { display:block; margin-bottom:4px; }
button { margin-top:6px; width:100%; padding:6px;
  border:none; border-radius:6px; background:#444; color:white; }
</style>
</head>
<body>

<div id="ui">
<strong>Relief Lab</strong><br><br>
<input type="file" id="imageLoader" accept="image/*"><br><br>

<div class="control">Resolution
<input type="range" id="resolution" min="40" max="160" value="80"></div>

<div class="control">Depth
<input type="range" id="depth" min="0.5" max="4" step="0.1" value="1.8"></div>

<div class="control">Frequency
<input type="range" id="frequency" min="0" max="1" step="0.05" value="0.5"></div>

<div class="toggles">
<label><input type="checkbox" id="invert"> Invert</label>
<label><input type="checkbox" id="curvature"> Curvature</label>
<label><input type="checkbox" id="ridges"> Ridges</label>
<label><input type="checkbox" id="autorotate"> Auto Rotate</label>
</div>

<button id="optimize">Optimize</button>
<button id="exportSTL">Export STL</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js');
}

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(40,40,160);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(120,80,150);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

let geometry, mesh, imageData=null;

const matStandard = new THREE.MeshStandardMaterial({
color:0xcccccc, roughness:0.8, metalness:0.1, side:THREE.DoubleSide
});
const matCurvature = new THREE.MeshNormalMaterial();
let currentMaterial = matStandard;

imageLoader.addEventListener("change", e=>{
const reader=new FileReader();
reader.onload=function(event){
const img=new Image();
img.onload=function(){
const canvas=document.createElement("canvas");
canvas.width=img.width; canvas.height=img.height;
const ctx=canvas.getContext("2d");
ctx.drawImage(img,0,0);
imageData=ctx.getImageData(0,0,img.width,img.height);
buildSurface();
};
img.src=event.target.result;
};
reader.readAsDataURL(e.target.files[0]);
});

function computeGradient(x,y){
if(!imageData) return 0;
const w=imageData.width;
function lum(px,py){
const i=(py*w+px)*4;
return (imageData.data[i]+imageData.data[i+1]+imageData.data[i+2])/3;
}
if(x<=1||y<=1||x>=w-2||y>=imageData.height-2) return 0;
const gx=lum(x+1,y)-lum(x-1,y);
const gy=lum(x,y+1)-lum(x,y-1);
return Math.sqrt(gx*gx+gy*gy)/255;
}

function buildSurface(){
if(!imageData) return;
if(mesh) scene.remove(mesh);

const res=parseInt(resolution.value);
geometry=new THREE.PlaneGeometry(150,150,res,res);
const pos=geometry.attributes.position;

for(let i=0;i<pos.count;i++){
const u=(pos.getX(i)+75)/150;
const v=(pos.getY(i)+75)/150;
const x=Math.floor(u*imageData.width);
const y=Math.floor(v*imageData.height);
const idx=(y*imageData.width+x)*4;
const lum=(imageData.data[idx]+imageData.data[idx+1]+imageData.data[idx+2])/3/255;
const edge=computeGradient(x,y);
const mix=parseFloat(frequency.value);
let height=(lum*(1-mix)+edge*mix);
if(invert.checked) height*=-1;
pos.setZ(i,height*80*depth.value);
}

pos.needsUpdate=true;
geometry.computeVertexNormals();

mesh=new THREE.Mesh(geometry,currentMaterial);
scene.add(mesh);

if(ridges.checked){
const edges=new THREE.EdgesGeometry(geometry);
const line=new THREE.LineSegments(edges,new THREE.LineBasicMaterial({color:0xff4444}));
mesh.add(line);
}
}

curvature.onchange=()=>{
currentMaterial=curvature.checked?matCurvature:matStandard;
if(mesh) mesh.material=currentMaterial;
};

optimize.onclick=()=>{
depth.value=2.2; frequency.value=0.6; buildSurface();
};

exportSTL.onclick=()=>{
if(!mesh) return;
const exporter=new THREE.STLExporter();
const result=exporter.parse(mesh);
const blob=new Blob([result],{type:'text/plain'});
const link=document.createElement("a");
link.href=URL.createObjectURL(blob);
link.download="relief.stl";
link.click();
};

resolution.oninput=buildSurface;
depth.oninput=buildSurface;
frequency.oninput=buildSurface;
invert.onchange=buildSurface;
ridges.onchange=buildSurface;

function animate(){
requestAnimationFrame(animate);
if(autorotate.checked && mesh) mesh.rotation.z+=0.003;
controls.update();
renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
camera.aspect=window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>

</body>
</html>