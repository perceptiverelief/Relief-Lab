<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Relief Lab ULTRA</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<link rel="manifest" href="manifest.json">
<style>
body{margin:0;overflow:hidden;background:#111;}
#ui{
position:absolute;top:10px;left:10px;width:300px;
background:rgba(0,0,0,.93);padding:12px;border-radius:10px;
color:white;font-family:Arial;font-size:13px;}
.control{margin-bottom:8px;}
.control input{width:100%;}
.toggles label{display:block;margin-bottom:4px;}
button{margin-top:6px;width:100%;padding:6px;
border:none;border-radius:6px;background:#444;color:white;}
</style>
</head>
<body>

<div id="ui">
<strong>Relief Lab ULTRA</strong><br><br>

<input type="file" id="imageLoader" accept="image/*"><br><br>

<div class="control">Resolution
<input type="range" id="resolution" min="40" max="160" value="80"></div>

<div class="control">Depth
<input type="range" id="depth" min="0.5" max="4" step="0.1" value="1.8"></div>

<div class="control">Frequency
<input type="range" id="frequency" min="0" max="1" step="0.05" value="0.5"></div>

<div class="control">Light X
<input type="range" id="lx" min="-200" max="200" value="120"></div>

<div class="control">Light Y
<input type="range" id="ly" min="-200" max="200" value="80"></div>

<div class="control">Light Z
<input type="range" id="lz" min="20" max="300" value="150"></div>

<div class="toggles">
<label><input type="checkbox" id="autoNorm"> Auto Normalize</label>
<label><input type="checkbox" id="ridgeDir"> Show Ridge Direction</label>
<label><input type="checkbox" id="detectText"> Detect Text</label>
<label><input type="checkbox" id="detectStroke"> Align Light to Strokes</label>
<label><input type="checkbox" id="autorotate"> Auto Rotate</label>
</div>

<button id="centerFace">Auto Center</button>
<button id="savePreset">Save Preset</button>
<button id="loadPreset">Load Preset</button>
<button id="exportSTL">Export STL</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

<script>
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x111111);

const camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,2000);
camera.position.set(40,40,160);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls=new THREE.OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;

const light=new THREE.DirectionalLight(0xffffff,1);
light.position.set(120,80,150);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

let geometry,mesh,imageData=null,dominantAngle=0;

const material=new THREE.MeshStandardMaterial({
color:0xcccccc,roughness:.8,metalness:.1,side:THREE.DoubleSide});

imageLoader.addEventListener("change",e=>{
const reader=new FileReader();
reader.onload=function(event){
const img=new Image();
img.onload=function(){
const canvas=document.createElement("canvas");
canvas.width=img.width;canvas.height=img.height;
const ctx=canvas.getContext("2d");
ctx.drawImage(img,0,0);
imageData=ctx.getImageData(0,0,img.width,img.height);
buildSurface();
};
img.src=event.target.result;
};
reader.readAsDataURL(e.target.files[0]);
});

function sobel(x,y){
const w=imageData.width;
function lum(px,py){
const i=(py*w+px)*4;
return (imageData.data[i]+imageData.data[i+1]+imageData.data[i+2])/3;
}
if(x<=1||y<=1||x>=w-2||y>=imageData.height-2)
return {mag:0,angle:0};

const gx=lum(x+1,y)-lum(x-1,y);
const gy=lum(x,y+1)-lum(x,y-1);
return {mag:Math.sqrt(gx*gx+gy*gy)/255,angle:Math.atan2(gy,gx)};
}

function buildSurface(){
if(!imageData)return;
if(mesh)scene.remove(mesh);

const res=parseInt(resolution.value);
geometry=new THREE.PlaneGeometry(150,150,res,res);
const pos=geometry.attributes.position;

let maxH=0,sumX=0,sumY=0,sumMag=0,sumAngleX=0,sumAngleY=0;

for(let i=0;i<pos.count;i++){
const u=(pos.getX(i)+75)/150;
const v=(pos.getY(i)+75)/150;
const x=Math.floor(u*imageData.width);
const y=Math.floor(v*imageData.height);
const idx=(y*imageData.width+x)*4;

const lum=(imageData.data[idx]+imageData.data[idx+1]+imageData.data[idx+2])/3/255;
const g=sobel(x,y);

const mix=parseFloat(frequency.value);
let h=(lum*(1-mix)+g.mag*mix);

maxH=Math.max(maxH,h);
sumX+=u*g.mag;
sumY+=v*g.mag;
sumMag+=g.mag;

sumAngleX+=Math.cos(g.angle)*g.mag;
sumAngleY+=Math.sin(g.angle)*g.mag;

pos.setZ(i,h*80*depth.value);
}

if(autoNorm.checked&&maxH>0){
for(let i=0;i<pos.count;i++){
pos.setZ(i,pos.getZ(i)/maxH*80);
}
}

pos.needsUpdate=true;
geometry.computeVertexNormals();

mesh=new THREE.Mesh(geometry,material);
scene.add(mesh);

if(sumMag>0){
const cx=(sumX/sumMag-0.5)*150;
const cy=(sumY/sumMag-0.5)*150;
controls.target.set(cx,cy,0);
controls.update();

dominantAngle=Math.atan2(sumAngleY,sumAngleX);
}

if(ridgeDir.checked){
const dir=new THREE.Vector3(Math.cos(dominantAngle),Math.sin(dominantAngle),0);
const arrow=new THREE.ArrowHelper(dir,new THREE.Vector3(0,0,20),30,0x00ff00);
mesh.add(arrow);
}

if(detectStroke.checked){
light.position.set(
Math.cos(dominantAngle+Math.PI/2)*150,
Math.sin(dominantAngle+Math.PI/2)*150,
150);
}

if(detectText.checked){
material.color.set(0xddddff);
}else{
material.color.set(0xcccccc);
}
}

centerFace.onclick=()=>buildSurface();

lx.oninput=()=>light.position.x=parseFloat(lx.value);
ly.oninput=()=>light.position.y=parseFloat(ly.value);
lz.oninput=()=>light.position.z=parseFloat(lz.value);

savePreset.onclick=()=>{
localStorage.setItem("reliefPreset",JSON.stringify({
resolution:resolution.value,
depth:depth.value,
frequency:frequency.value,
lx:light.position.x,
ly:light.position.y,
lz:light.position.z
}));
};

loadPreset.onclick=()=>{
const p=JSON.parse(localStorage.getItem("reliefPreset"));
if(!p)return;
resolution.value=p.resolution;
depth.value=p.depth;
frequency.value=p.frequency;
light.position.set(p.lx,p.ly,p.lz);
buildSurface();
};

exportSTL.onclick=()=>{
if(!mesh)return;
const exporter=new THREE.STLExporter();
const result=exporter.parse(mesh);
const blob=new Blob([result],{type:'text/plain'});
const link=document.createElement("a");
link.href=URL.createObjectURL(blob);
link.download="relief.stl";
link.click();
};

resolution.oninput=buildSurface;
depth.oninput=buildSurface;
frequency.oninput=buildSurface;

function animate(){
requestAnimationFrame(animate);
if(autorotate.checked&&mesh)mesh.rotation.z+=0.003;
controls.update();
renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
camera.aspect=window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
